3d2
<  * Extensions for ORW: Copyright (c) 2012-2013 Olaf Landsiedel
39d37
<  * @author Olaf Landsiedel
46d43
< #include "oppDebug.h"
80,82d76
<   uses interface Opp;
<   uses interface AsyncUnique;
<   uses interface OppDebug;
100c94
<     SACK_HEADER_LENGTH = 9,
---
>     SACK_HEADER_LENGTH = 7,
126,133d119
<   bool acceptMsg;
< //  bool dup;
< //  uint8_t dsnTemp;
< //  uint16_t srcTemp;
< //  uint8_t accteptTemp;    
<   uint16_t msgSource;
<   uint8_t msgDsn;
< 
163,164d148
< //  task void dupLog_task();
<   task void pull_task();
169,170d152
<     acceptMsg = FALSE; 
< //    dup = FALSE;
336a319,322
> 
> #if ! defined(TFRAMES_ENABLED)
>     atomic secHdrPos = (pos+11)%RXFIFO_SIZE;
> #else
337a324
> #endif
537c524
<         
---
>   
608,613c595,600
<        */	  
<       if(call CC2420Config.isAutoAckEnabled() && !call CC2420Config.isHwAutoAckDefault()
<             && ((( header->fcf >> IEEE154_FCF_FRAME_TYPE ) & 7) == IEEE154_TYPE_DATA) 
< 			&& header->destpan == TOS_AM_GROUP && call Opp.acceptMsg(header->dest) ){
< 		acceptMsg = TRUE; 		
<        	if ( call AsyncUnique.check(header->src, header->dsn) && (( header->fcf >> IEEE154_FCF_ACK_REQ ) & 0x01) == 1){
---
>        */
>       if(call CC2420Config.isAutoAckEnabled() && !call CC2420Config.isHwAutoAckDefault()) {
>         if (((( header->fcf >> IEEE154_FCF_ACK_REQ ) & 0x01) == 1)
>             && ((header->dest == call CC2420Config.getShortAddr())
>                 || (header->dest == AM_BROADCAST_ADDR))
>             && ((( header->fcf >> IEEE154_FCF_FRAME_TYPE ) & 7) == IEEE154_TYPE_DATA)) {
615,627c602,610
< 	      call CSN.set();
< 	      call CSN.clr();
< 		  call SACK.strobe();
< 		  call CSN.set();
< 		  call CSN.clr();
< 		  call RXFIFO.beginRead(buf + 1 + SACK_HEADER_LENGTH,
< 		  rxFrameLength - SACK_HEADER_LENGTH);
< 		  return;
< 	    } 
< //	  } else if (header->dest == IEEE154_BROADCAST_ADDR){
< //		acceptMsg = TRUE; 				  
< 	  } else {
<         acceptMsg = FALSE; 
---
>           call CSN.set();
>           call CSN.clr();
>           call SACK.strobe();
>           call CSN.set();
>           call CSN.clr();
> 	  call RXFIFO.beginRead(buf + 1 + SACK_HEADER_LENGTH,
> 				rxFrameLength - SACK_HEADER_LENGTH);
>           return;
>         }
664c647
<         uint8_t type = ( header->fcf >> IEEE154_FCF_FRAME_TYPE ) & 7;        
---
>         uint8_t type = ( header->fcf >> IEEE154_FCF_FRAME_TYPE ) & 7;
666,683c649,651
<         if ( type == IEEE154_TYPE_DATA && header->destpan == TOS_AM_GROUP){
<           call Opp.update(header->dest, header->src, acceptMsg);
< //          if( dup ){
< //          	dsnTemp = header->dsn;
< //          	srcTemp = header->src;
< //          	accteptTemp = acceptMsg;
< //          	dup = FALSE;
< //          	post dupLog_task();
< //          }
<           if( acceptMsg ) {
<             post receiveDone_task();
<             return;
<           } 
<           if( ((opp_header_t*)m_p_rx_buf->data)->pull ){
<           	msgSource = header->src;
<           	msgDsn = header->dsn;
<           	post pull_task();
<           }
---
>         if ( type == IEEE154_TYPE_DATA ) {
>           post receiveDone_task();
>           return;
703,724d670
< //  task void dupLog_task(){
< //  	uint8_t dsnLocal;
< //  	uint16_t srcLocal;
< //  	uint8_t acceptLocal;
< //  	atomic{
< //  		dsnLocal = dsnTemp;
< //  		srcLocal = srcTemp;
< //  		acceptLocal = accteptTemp;
< //  	}
< //	call OppDebug.logEventMsg(NET_LL_DUPLICATE, dsnLocal, acceptLocal, srcLocal);			
< //  }
<   
<   task void pull_task(){
<   	uint8_t dsnLocal;
<   	uint16_t srcLocal;
<   	atomic{
<   		dsnLocal = msgDsn;
<   		srcLocal = msgSource;
<   	}
<   	call Opp.pull(srcLocal, dsnLocal);
<   }
<   
737,738d682
<  	header->dest = TOS_NODE_ID;		
<     
894c838
<       ext_addr = (ieee_eui64_t *)&header->dest;
---
>       ext_addr = TCAST(ieee_eui64_t* ONE, &header->dest);
900a845
> 
